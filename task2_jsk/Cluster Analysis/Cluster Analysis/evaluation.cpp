#include <iostream>
#include <io.h>
#include <fstream>
#include <vector>
#include <algorithm>
#include <map>
#include "head.h"
#include "bi_kmeans.h"
#include "dbscan.h"
#include "evaluation.h"

using namespace std;

typedef map<int, vector<int>> CLASS_MAP;
typedef vector<vector<int>> CLUSTER_VEC;

void evaluate_cluster(int data_size, CLASS_MAP &classes, vector<int> clusters[], int cluster_num)
{
	int i;
	int j;
	int k;
	int l;
	int count;
	int class_num = classes.size();
	int **common_num = new int*[class_num];
	double precision;
	double recall;
	double purity = 0;
	double FScore = 0;
	double **f_score = new double*[class_num];
	CLASS_MAP::iterator it;

	for (i = 0; i < class_num; ++i)
	{
		common_num[i] = new int[cluster_num];
		f_score[i] = new double[cluster_num];
	}

	for (it = classes.begin(), i = 0; i < class_num; ++it, ++i)
	{
		for (j = 0; j < cluster_num; ++j)
		{
			count = 0;
			k = 0;
			l = 0;
			while (k < it->second.size() && l < clusters[j].size())
			{
				if (it->second[k] < clusters[j][l])
				{
					++k;
				}
				else if (it->second[k] > clusters[j][l])
				{
					++l;
				}
				else
				{
					++count;
					++k;
					++l;
				}
			}

			common_num[i][j] = count;
			precision = (double)(count) / clusters[j].size();
			recall = (double)(count) / it->second.size();
			if (precision == 0 && recall == 0)
			{
				f_score[i][j] = 0;
			}
			else
			{
				f_score[i][j] = precision * recall * 2 / (precision + recall);
			}
		}
	}

	for (j = 0; j < cluster_num; ++j)
	{
		for (i = 1; i < class_num; ++i)
		{
			if (common_num[i][j] > common_num[0][j])
			{
				common_num[0][j] = common_num[i][j];
			}
		}
	}
	for (j = 0, count = 0; j < cluster_num; ++j)
	{
		purity += common_num[0][j];
		count += clusters[j].size();
	}
	if (count > data_size)
	{
		cout<<"Error in clustering!"<<endl;
		return;
	}
	purity /= count;
	cout<<"purity = "<<purity<<", ";

	for (i = 0; i < class_num; ++i)
	{
		for (j = 1; j < cluster_num; ++j)
		{
			if (f_score[i][j] > f_score[i][0])
			{
				f_score[i][0] = f_score[i][j];
			}
		}
	}
	for (it = classes.begin(), i = 0; i < class_num; ++it, ++i)
	{
		FScore += f_score[i][0] * it->second.size();
	}
	FScore /= data_size;
	cout<<"F-score = "<<FScore<<endl;

	for (i = 0; i < class_num; ++i)
	{
		delete [] common_num[i];
		delete [] f_score[i];
	}
	delete [] common_num;
	delete [] f_score;
}

void evaluate_dataset(int number, const int para_k[], const double para_eps[], const int para_minPts[])
{
	int i;
	int j;
	int data_size;
	int data;
	char file_name[100];
	ifstream inFile;
	CLASS_MAP classes;
	CLASS_MAP::iterator it;

	cout<<"dataset: dataset"<<number<<endl;
	if (number == 1)
	{
		data_size = SIZE1;
	}
	else
	{
		data_size = SIZE2;
	}
	sprintf(file_name, "dataset%d-label.dat", number);
	inFile.open(file_name, ios::in);
	if (inFile.fail())
	{
		cout<<"The file "<<file_name<<"does not exist!"<<endl;
		return;
	}
	for (i = 0; i < data_size; ++i)
	{
		inFile>>data;
		it = classes.find(data);
		if (it != classes.end())
		{
			it->second.push_back(i);
		}
		else
		{
			vector<int> temp;
			temp.push_back(i);
			classes.insert(CLASS_MAP::value_type(data, temp));
		}
	}
	inFile.close();

	cout<<"method: bisecting k-means"<<endl;
	for (i = 0; i < KNUM; ++i)
	{
		vector<int> *cluster = new vector<int>[para_k[i]];
		for (j = 0; j < para_k[i]; ++j)
		{
			sprintf(file_name, "clusters\\dataset%d\\bisecting k-means\\%d\\%d.dat", number, para_k[i], j);
			inFile.open(file_name, ios::in);
			if (inFile.fail())
			{
				cout<<"There exist no clusters generated by bisecting k-means (k = "<<para_k[i]<<")!"<<endl;
				return;
			}
			while (!inFile.eof())
			{
				inFile>>data;
				cluster[j].push_back(data);
			}
			inFile.close();
		}
		cout<<"k = "<<para_k[i]<<": ";
		evaluate_cluster(data_size, classes, cluster, para_k[i]);

		delete [] cluster;
	}
	cout<<endl;

	cout<<"method: dbscan"<<endl;
	for (i = 0; i < PNUM; ++i)
	{
		for (j = 0; j < PNUM; ++j)
		{
			int k;
			int cluster_num;
			long lf;
			_finddata_t file;
			vector<int> *cluster;
			CLUSTER_VEC cluster_v;

			sprintf(file_name, "clusters\\dataset%d\\dbscan\\%.1f\\%d\\*.dat", number, para_eps[i], para_minPts[j]);
			if ((lf = _findfirst(file_name, &file)) == -1)
			{
				cout<<"There exist no clusters generated by dbscan (eps = "<<para_eps[i]<<", minPts = "<<para_minPts[j]<<")!"<<endl;
				return;
			}
			do 
			{
				vector<int> cluster_temp;
				sprintf(file_name, "clusters\\dataset%d\\dbscan\\%.1f\\%d\\%s", number, para_eps[i], para_minPts[j], file.name);
				inFile.open(file_name, ios::in);
				while (!inFile.eof())
				{
					inFile>>data;
					cluster_temp.push_back(data);
				}
				inFile.close();
				cluster_v.push_back(cluster_temp);
			} while (_findnext(lf, &file) == 0);
			_findclose(lf);

			cluster_num = cluster_v.size();
			cluster = new vector<int>[cluster_num];
			for (k = 0; k < cluster_num; ++k)
			{
				cluster[k].swap(cluster_v[k]);
			}
			cout<<"eps = "<<para_eps[i]<<", minPts = "<<para_minPts[j]<<": ";
			evaluate_cluster(data_size, classes, cluster, cluster_num);

			delete [] cluster;
		}
	}
	cout<<endl;
}

void evaluate()
{
	evaluate_dataset(1, para1_k, para1_eps, para1_minPts);
	evaluate_dataset(2, para2_k, para2_eps, para2_minPts);
}